{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 77,
   "metadata": {
    "metadata": {}
   },
   "outputs": [],
   "source": [
    "import os\n",
    "import json\n",
    "import pretty_midi\n",
    "import tensorflow as tf\n",
    "import numpy as np\n",
    "import random\n",
    "import glob\n",
    "\n",
    "def scan_midi_files(directory, max_files=None):\n",
    "    \"\"\"\n",
    "    Scans the specified directory for MIDI files using glob with a while loop.\n",
    "\n",
    "    Args:\n",
    "        directory (str): The directory to scan for MIDI files.\n",
    "        max_files (int, optional): The maximum number of files to scan. If None, all files are scanned.\n",
    "\n",
    "    Returns:\n",
    "        list: The list of MIDI files found.\n",
    "    \"\"\"\n",
    "    search_pattern = os.path.join(directory, '**', '*.mid*')\n",
    "    midi_files = []\n",
    "\n",
    "    # Utiliser glob.iglob pour obtenir un itérateur\n",
    "    for file in glob.iglob(search_pattern, recursive=True):\n",
    "        midi_files.append(file)\n",
    "        if max_files is not None and len(midi_files) >= max_files:\n",
    "            break\n",
    "\n",
    "    return midi_files\n",
    "\n",
    "midi_files = scan_midi_files('_djai-files/_maestro-sample', max_files=2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# reconstruction en plusieurs classes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 75,
   "metadata": {
    "metadata": {}
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\u001b[1m239/239\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m8s\u001b[0m 13ms/step - instrument_index_accuracy: 0.9834 - loss: 7.7212\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import pretty_midi\n",
    "import tensorflow as tf\n",
    "\n",
    "\n",
    "class DataProcessor:\n",
    "    def __init__(self, sequence_length_i, sequence_length_o, num_instruments):\n",
    "        self.sequence_length_i = sequence_length_i\n",
    "        self.sequence_length_o = sequence_length_o\n",
    "        self.num_instruments = num_instruments\n",
    "        # feature indices metadata\n",
    "        self.feature_config = {\n",
    "            'numerical_features': slice(0, 4),  # assuming first 4 features are numerical\n",
    "            'instrument_features': slice(4, None)  # assuming features from index 4 onwards are instrument\n",
    "        }\n",
    "        self.numerical_indices = self.feature_config['numerical_features']\n",
    "        self.instrument_indices = self.feature_config['instrument_features']\n",
    "        self.means = None\n",
    "        self.stds = None\n",
    "\n",
    "    def extract_features(self, notes, instrument_index, midi_data):\n",
    "        # Get tempo changes and tick per beat\n",
    "        tempo_changes = midi_data.get_tempo_changes()\n",
    "        tick_per_beat = midi_data.resolution\n",
    "        \n",
    "        # Interpolate tempo changes to find the tempo at each note start time\n",
    "        tempos = np.interp([note.start for note in notes], tempo_changes[0], tempo_changes[1])\n",
    "        ticks_to_quarters = 60.0 / (tempos / tick_per_beat)  # Converts ticks to quarter note length\n",
    "\n",
    "        # Calculate features using interpolated ticks to quarters for each note\n",
    "        pitches = [note.pitch for note in notes]\n",
    "        durations = [(note.end - note.start) / tpb for note, tpb in zip(notes, ticks_to_quarters)]\n",
    "        offsets = [note.start / tpb for note, tpb in zip(notes, ticks_to_quarters)]\n",
    "        time_deltas = [offsets[i] - (offsets[i-1] + durations[i-1]) if i > 0 else offsets[0] for i in range(len(notes))]\n",
    "        \n",
    "        instrument_indices = [instrument_index] * len(notes)\n",
    "        return np.stack([pitches, durations, offsets, time_deltas, instrument_indices], axis=1)\n",
    "\n",
    "    def midi_files_to_sequences(self, midi_files):\n",
    "        all_sequences = []\n",
    "        for midi_file in midi_files:\n",
    "            midi_data = pretty_midi.PrettyMIDI(midi_file)\n",
    "            for instrument in midi_data.instruments:\n",
    "                notes = instrument.notes\n",
    "                if len(notes) < self.sequence_length_i + self.sequence_length_o:\n",
    "                    continue\n",
    "                for i in range(len(notes) - self.sequence_length_i - self.sequence_length_o + 1):\n",
    "                    sequence = notes[i:i + self.sequence_length_i + self.sequence_length_o]\n",
    "                    features = self.extract_features(sequence, instrument.program, midi_data)\n",
    "                    all_sequences.append(features)\n",
    "        return np.array(all_sequences)\n",
    "\n",
    "    def compute_scaling_parameters(self, sequences):\n",
    "        self.means = np.nanmean(sequences[:, :, self.numerical_indices], axis=(0, 1))\n",
    "        self.stds = np.nanstd(sequences[:, :, self.numerical_indices], axis=(0, 1))\n",
    "\n",
    "    def scale_numerical_features(self, numerical_sequences):\n",
    "        if self.means is None or self.stds is None:\n",
    "            self.compute_scaling_parameters(numerical_sequences)\n",
    "        sequences_scaled = (numerical_sequences - self.means) / self.stds\n",
    "        return sequences_scaled\n",
    "    \n",
    "    def preprocess_data(self, sequences):\n",
    "        numerical_sequences = sequences[:, :, self.numerical_indices]\n",
    "        scaled_numerical_sequences = self.scale_numerical_features(numerical_sequences)\n",
    "        instrument_sequences = sequences[:, :, self.instrument_indices]\n",
    "\n",
    "        # One-hot encoding for instrument indices for both inputs and outputs\n",
    "        instrument_indices = instrument_sequences.astype(int).reshape(-1)\n",
    "        one_hot_instruments = np.eye(self.num_instruments)[instrument_indices]\n",
    "        one_hot_instruments = one_hot_instruments.reshape(instrument_sequences.shape[0], instrument_sequences.shape[1], self.num_instruments)\n",
    "\n",
    "        #print(\"scaled sequences shape:\", scaled_numerical_sequences.shape)\n",
    "        #print(\"one hot instruments shape:\", one_hot_instruments.shape)\n",
    "\n",
    "        # Concatenate scaled features with one-hot encoded instrument indices\n",
    "        numerical_input_data = scaled_numerical_sequences[:, :self.sequence_length_i, self.numerical_indices]\n",
    "        nunerical_output_data = scaled_numerical_sequences[:, self.sequence_length_i:, self.numerical_indices]\n",
    "        instrument_input_data = one_hot_instruments[:, :self.sequence_length_i]\n",
    "        instrument_output_data = one_hot_instruments[:, self.sequence_length_i:]\n",
    "        inputs = np.concatenate([numerical_input_data, instrument_input_data], axis=-1)\n",
    "        outputs = [nunerical_output_data[:, :, i] for i in range(nunerical_output_data.shape[2])]\n",
    "        outputs.append(instrument_output_data)  # Add one-hot encoded instrument index as the last output\n",
    "\n",
    "        return inputs, tuple(outputs)\n",
    "    \n",
    "    def prepare_data(self, midi_files):\n",
    "        sequences = self.midi_files_to_sequences(midi_files)\n",
    "        inputs, outputs = self.preprocess_data(sequences)\n",
    "        return inputs, outputs\n",
    "\n",
    "\n",
    "@tf.keras.utils.register_keras_serializable()\n",
    "class PositionalEncoding(tf.keras.layers.Layer):\n",
    "    def __init__(self, position, d_model, **kwargs):\n",
    "        super(PositionalEncoding, self).__init__(**kwargs)\n",
    "        self.position = position\n",
    "        self.d_model = d_model\n",
    "        self.pos_encoding = self.positional_encoding(position, d_model)\n",
    "\n",
    "    def get_angles(self, position, i, d_model):\n",
    "        angles = 1 / np.power(10000, (2 * (i // 2)) / np.float32(d_model))\n",
    "        return position * angles\n",
    "\n",
    "    def positional_encoding(self, position, d_model):\n",
    "        angle_rads = self.get_angles(np.arange(position)[:, np.newaxis],\n",
    "                                     np.arange(d_model)[np.newaxis, :],\n",
    "                                     d_model)\n",
    "        sines = np.sin(angle_rads[:, 0::2])\n",
    "        cosines = np.cos(angle_rads[:, 1::2])\n",
    "        pos_encoding = np.concatenate([sines, cosines], axis=-1)[np.newaxis, ...]\n",
    "        return tf.cast(pos_encoding, dtype=tf.float32)\n",
    "\n",
    "    def call(self, inputs):\n",
    "        return inputs + self.pos_encoding[:, :tf.shape(inputs)[1], :]\n",
    "\n",
    "    def get_config(self):\n",
    "        config = super().get_config()  # Make sure the super call is appropriate.\n",
    "        config.update({\n",
    "            'position': self.position,\n",
    "            'd_model': self.d_model\n",
    "        })\n",
    "        return config\n",
    "\n",
    "class ModelManager:\n",
    "    def __init__(self, sequence_length_i=30, sequence_length_o=10, num_instruments=2, model_type='lstm', n_layers=3, n_units=128, dropout=0.2, batch_size=32, learning_rate=0.005, num_heads=2, loss_weights=None):\n",
    "        self.sequence_length_i = sequence_length_i\n",
    "        self.sequence_length_o = sequence_length_o\n",
    "        self.num_instruments = num_instruments\n",
    "        self.num_features = 5  # pitch, duration, offset, time_delta, instrument_index\n",
    "        self.learning_rate = learning_rate\n",
    "        self.batch_size = batch_size\n",
    "        self.loss_weights = loss_weights if loss_weights else {'pitch': 1.0, 'duration': 1.0, 'offset': 1.0, 'time_delta': 100.0, 'instrument_index': 100.0}\n",
    "        self.data_processor = DataProcessor(sequence_length_i, sequence_length_o, num_instruments)\n",
    "        self.model = self._create_default_model(n_layers, n_units, dropout, num_heads, model_type, num_instruments)\n",
    "        \n",
    "    def _create_default_model(self, n_layers, n_units, dropout, num_heads, model_type, num_instruments):\n",
    "        n_features_onehot = self.num_features - 1 + num_instruments\n",
    "        input_shape = (self.sequence_length_i, n_features_onehot)\n",
    "        inputs = tf.keras.Input(shape=input_shape)\n",
    "\n",
    "        x = inputs\n",
    "        if model_type == 'transformer':\n",
    "            positional_encoding_layer = PositionalEncoding(self.sequence_length_i, n_features_onehot)\n",
    "            x = positional_encoding_layer(x)\n",
    "            for i in range(n_layers):\n",
    "                attention_output = tf.keras.layers.MultiHeadAttention(num_heads=num_heads, key_dim=n_units)(x, x)\n",
    "                x = tf.keras.layers.Dropout(dropout)(x)\n",
    "                x = tf.keras.layers.LayerNormalization(epsilon=1e-6)(x + attention_output)\n",
    "                ff_output = tf.keras.Sequential([\n",
    "                    tf.keras.layers.Dense(n_units, activation='relu'),\n",
    "                    tf.keras.layers.Dense(x.shape[-1]),\n",
    "                ])(x)\n",
    "                x = tf.keras.layers.LayerNormalization(epsilon=1e-6)(x + ff_output)\n",
    "        else:\n",
    "            for i in range(n_layers):\n",
    "                if model_type == 'lstm':\n",
    "                    x = tf.keras.layers.LSTM(n_units, return_sequences=True, dropout=dropout)(x)\n",
    "                elif model_type == 'gru':\n",
    "                    x = tf.keras.layers.GRU(n_units, return_sequences=True, dropout=dropout)(x)\n",
    "\n",
    "        # Using direct slicing here\n",
    "        x = x[:, -self.sequence_length_o:]\n",
    "\n",
    "        outputs = [\n",
    "            tf.keras.layers.Dense(1, name=f\"{feature}\")(x) for feature in [\"pitch\", \"duration\", \"offset\", \"time_delta\"]\n",
    "        ]\n",
    "        if num_instruments > 1:\n",
    "            instruments_output = tf.keras.layers.TimeDistributed(\n",
    "                tf.keras.layers.Dense(num_instruments, activation='softmax'), name='instrument_index'\n",
    "            )(x)\n",
    "        else:\n",
    "            instruments_output = tf.keras.layers.TimeDistributed(\n",
    "                tf.keras.layers.Dense(1, activation='sigmoid'), name='instrument_index'\n",
    "            )(x)\n",
    "        outputs.append(instruments_output)\n",
    "\n",
    "        model = tf.keras.Model(inputs=inputs, outputs=outputs)\n",
    "        model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=self.learning_rate),\n",
    "                      loss={'pitch': 'mean_squared_error',\n",
    "                            'duration': 'mean_squared_error',\n",
    "                            'offset': 'mean_squared_error',\n",
    "                            'time_delta': 'mean_squared_error',\n",
    "                            'instrument_index': 'categorical_crossentropy' if num_instruments > 1 else 'binary_crossentropy'},\n",
    "                      loss_weights=self.loss_weights,\n",
    "                      metrics={'instrument_index': 'accuracy'})\n",
    "        return model\n",
    "    \n",
    "    def fit(self, midi_files, epochs=10):\n",
    "        inputs, targets = self.data_processor.prepare_data(midi_files)\n",
    "        dataset = tf.data.Dataset.from_tensor_slices((inputs, targets)).batch(self.batch_size)\n",
    "        history = self.model.fit(dataset, epochs=epochs)\n",
    "        return history\n",
    "    \n",
    "    def scaled_back(self, predicted_outputs):\n",
    "        rescaled_outputs = predicted_outputs.copy()\n",
    "        numerical_indices = self.data_processor.numerical_indices\n",
    "        means = self.data_processor.means\n",
    "        stds = self.data_processor.stds\n",
    "        for i in range(predicted_outputs.shape[2]):  # Loop over the last dimension (features)\n",
    "            if i in range(numerical_indices.start, numerical_indices.stop): \n",
    "                rescaled_outputs[:, :, i] = predicted_outputs[:, :, i] * stds[i - numerical_indices.start] + means[i - numerical_indices.start]\n",
    "        return rescaled_outputs\n",
    "\n",
    "    def sequences_to_track_list(self, predicted_sequences):\n",
    "        tracks = []\n",
    "        instrument_indices = self.data_processor.instrument_indices\n",
    "        numerical_indices = self.data_processor.numerical_indices\n",
    "        for i in range(self.num_instruments):\n",
    "            track = []\n",
    "            for j in range(predicted_sequences.shape[1]):\n",
    "                max_instrument_index = np.argmax(predicted_sequences[0, j, instrument_indices])\n",
    "                if max_instrument_index == i:\n",
    "                    pitch = int(round(predicted_sequences[0, j, numerical_indices.start]))\n",
    "                    duration = predicted_sequences[0, j, numerical_indices.start + 1]\n",
    "                    offset = predicted_sequences[0, j, numerical_indices.start + 2]\n",
    "                    track.append((pitch, duration, offset))\n",
    "            tracks.append(track)\n",
    "\n",
    "        return tracks\n",
    "    \n",
    "    def generate(self, midi_file_path, length=10):\n",
    "        if isinstance(midi_file_path, str):\n",
    "            midi_file_path = [midi_file_path]\n",
    "        inputs, _ = self.data_processor.prepare_data(midi_file_path)\n",
    "        if inputs.size == 0:\n",
    "            print(\"No sequences extracted, possibly too few notes.\")\n",
    "            return None\n",
    "        input_data = inputs[0:1, :self.sequence_length_i, :] # 0:1 for only use the first sequence\n",
    "        predictions = self.model.predict(input_data, verbose=0)\n",
    "        predictions = np.concatenate(predictions, axis=2) # the prediction has one output for each feature (necessary for loss calculation)\n",
    "        if predictions.shape[1] > length:\n",
    "            predictions = predictions[:, :length, :]\n",
    "        else:\n",
    "            total_steps = length - predictions.shape[1]\n",
    "            for _ in range(total_steps):\n",
    "                input_data = np.concatenate((input_data[:, 1:, :], predictions[:, -1:, :]), axis=1)\n",
    "                next_step = np.concatenate(self.model.predict(input_data, verbose=0), axis=2)\n",
    "                predictions = np.concatenate((predictions, next_step), axis=1)\n",
    "\n",
    "        predictions = self.scaled_back(predictions)\n",
    "        #print(\"Print predictions:\", predictions)\n",
    "        tracks = self.sequences_to_track_list(predictions)\n",
    "        return tracks\n",
    "\n",
    "    def save(self, filepath):\n",
    "        self.model.save(filepath)\n",
    "\n",
    "    @staticmethod\n",
    "    def load(filepath):\n",
    "        return tf.keras.models.load_model(filepath, custom_objects={'PositionalEncoding': PositionalEncoding})\n",
    "    \n",
    "model_manager = ModelManager(\n",
    "    sequence_length_i=30, sequence_length_o=10,\n",
    "    num_instruments=2, model_type='lstm',\n",
    "    n_layers=10, n_units=128, dropout=0.2, batch_size=32,\n",
    "    learning_rate=0.005, num_heads=2, loss_weights=None\n",
    ")\n",
    "history = model_manager.fit(midi_files, epochs=100)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "metadata": {
    "metadata": {}
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\u001b[1m1/1\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m0s\u001b[0m 413ms/step\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "[[(61, 0.00020783936, 0.9858283),\n",
       "  (61, 0.00020751567, 0.9872776),\n",
       "  (61, 0.00021605322, 0.98345363),\n",
       "  (61, 0.00022186595, 0.98560524),\n",
       "  (61, 0.00021167187, 0.98685807),\n",
       "  (61, 0.00021211279, 0.9885052),\n",
       "  (61, 0.00021108292, 0.98871875),\n",
       "  (61, 0.00021412107, 0.9883921),\n",
       "  (61, 0.00021287397, 0.98783237),\n",
       "  (61, 0.00021765684, 0.9853373),\n",
       "  (61, 0.00020751532, 0.98728615),\n",
       "  (61, 0.0002160467, 0.9834629),\n",
       "  (61, 0.00022186304, 0.9856181),\n",
       "  (61, 0.00021167402, 0.986868),\n",
       "  (61, 0.0002121143, 0.98851436),\n",
       "  (61, 0.00021107041, 0.98872346),\n",
       "  (61, 0.00021411158, 0.98839957),\n",
       "  (61, 0.00021287106, 0.98784006),\n",
       "  (61, 0.00021765381, 0.9853444),\n",
       "  (61, 0.00022587623, 0.9948089),\n",
       "  (61, 0.00021607807, 0.98355263),\n",
       "  (61, 0.00022189645, 0.985697),\n",
       "  (61, 0.00021170313, 0.9869311),\n",
       "  (61, 0.00021213875, 0.98856676),\n",
       "  (61, 0.0002110594, 0.9887605),\n",
       "  (61, 0.00021411001, 0.9884357),\n",
       "  (61, 0.0002128791, 0.98787206),\n",
       "  (61, 0.00021765928, 0.9853725),\n",
       "  (61, 0.00022588525, 0.9948338),\n",
       "  (61, 0.00022800174, 0.99925673),\n",
       "  (61, 0.00022195437, 0.9858123),\n",
       "  (61, 0.0002117519, 0.98702294),\n",
       "  (61, 0.00021218031, 0.9886424),\n",
       "  (61, 0.00021105359, 0.98881394),\n",
       "  (61, 0.00021411723, 0.98848647),\n",
       "  (61, 0.00021289679, 0.9879168),\n",
       "  (61, 0.00021767232, 0.9854113),\n",
       "  (61, 0.0002259023, 0.9948676),\n",
       "  (61, 0.00022802065, 0.99928683),\n",
       "  (61, 0.00022983958, 1.002715),\n",
       "  (61, 0.00021181937, 0.9871497),\n",
       "  (61, 0.00021223788, 0.98874664),\n",
       "  (61, 0.00021104817, 0.98888665),\n",
       "  (61, 0.00021413103, 0.9885551),\n",
       "  (61, 0.00021292432, 0.9879774),\n",
       "  (61, 0.00021769298, 0.9854638),\n",
       "  (61, 0.00022592762, 0.9949133),\n",
       "  (61, 0.00022804807, 0.9993269),\n",
       "  (61, 0.00022986636, 1.0027506),\n",
       "  (61, 0.00023089722, 1.0052534),\n",
       "  (61, 0.00021231826, 0.9888686),\n",
       "  (61, 0.00021107157, 0.9889708),\n",
       "  (61, 0.00021417043, 0.9886294),\n",
       "  (61, 0.00021296833, 0.9880414),\n",
       "  (61, 0.00021772704, 0.9855184),\n",
       "  (61, 0.00022596208, 0.99495834),\n",
       "  (61, 0.00022808183, 0.99936545),\n",
       "  (61, 0.00022989762, 1.0027839),\n",
       "  (61, 0.0002309258, 1.005282),\n",
       "  (61, 0.00023149024, 1.0070858),\n",
       "  (61, 0.00021105359, 0.98907906),\n",
       "  (61, 0.00021418504, 0.988731),\n",
       "  (61, 0.00021300575, 0.98813117),\n",
       "  (61, 0.00021775585, 0.9855966),\n",
       "  (61, 0.00022599864, 0.9950259),\n",
       "  (61, 0.00022812159, 0.9994248),\n",
       "  (61, 0.00022993644, 1.0028362),\n",
       "  (61, 0.0002309616, 1.0053279),\n",
       "  (61, 0.00023152289, 1.0071259),\n",
       "  (61, 0.00023181573, 1.0084102),\n",
       "  (61, 0.00021422486, 0.9887673),\n",
       "  (61, 0.00021304365, 0.98816353),\n",
       "  (61, 0.00021778425, 0.9856238),\n",
       "  (61, 0.00022602658, 0.9950491),\n",
       "  (61, 0.00022814935, 0.9994461),\n",
       "  (61, 0.00022996322, 1.0028558),\n",
       "  (61, 0.00023098732, 1.005346),\n",
       "  (61, 0.00023154687, 1.0071425),\n",
       "  (61, 0.00023183797, 1.0084252),\n",
       "  (61, 0.00023198058, 1.0093347),\n",
       "  (61, 0.00021310488, 0.9882653),\n",
       "  (61, 0.00021783198, 0.98571104),\n",
       "  (61, 0.00022607832, 0.9951227),\n",
       "  (61, 0.00022820133, 0.9995095),\n",
       "  (61, 0.00023001147, 1.002911),\n",
       "  (61, 0.00023103075, 1.0053936),\n",
       "  (61, 0.00023158547, 1.0071836),\n",
       "  (61, 0.00023187196, 1.0084606),\n",
       "  (61, 0.00023201044, 1.009365),\n",
       "  (61, 0.00023207022, 1.0100014),\n",
       "  (61, 0.00021787244, 0.98584276),\n",
       "  (61, 0.00022613269, 0.99523616),\n",
       "  (61, 0.00022826286, 0.9996089),\n",
       "  (61, 0.0002300716, 1.0029984),\n",
       "  (61, 0.00023108633, 1.0054699),\n",
       "  (61, 0.00023163564, 1.0072495),\n",
       "  (61, 0.00023191667, 1.0085176),\n",
       "  (61, 0.00023204967, 1.0094138),\n",
       "  (61, 0.0002321048, 1.0100431),\n",
       "  (61, 0.00023212278, 1.0104828),\n",
       "  (61, 0.00022618618, 0.9952468),\n",
       "  (61, 0.0002283121, 0.99962133),\n",
       "  (61, 0.00023011869, 1.0030122),\n",
       "  (61, 0.00023113127, 1.0054848),\n",
       "  (61, 0.0002316783, 1.0072652),\n",
       "  (61, 0.00023195636, 1.0085336),\n",
       "  (61, 0.00023208634, 1.0094296),\n",
       "  (61, 0.00023213809, 1.0100584),\n",
       "  (61, 0.00023215252, 1.0104971),\n",
       "  (61, 0.00023215212, 1.0108019),\n",
       "  (61, 0.00022837456, 0.99970186),\n",
       "  (61, 0.00023018086, 1.0030863),\n",
       "  (61, 0.00023118989, 1.0055522),\n",
       "  (61, 0.00023173157, 1.0073254),\n",
       "  (61, 0.00023200421, 1.0085866),\n",
       "  (61, 0.00023212872, 1.0094761),\n",
       "  (61, 0.0002321754, 1.0100987),\n",
       "  (61, 0.00023218535, 1.010532),\n",
       "  (61, 0.00023218064, 1.010832),\n",
       "  (61, 0.00023217191, 1.0110387),\n",
       "  (61, 0.00023024163, 1.0031394),\n",
       "  (61, 0.00023124774, 1.005603),\n",
       "  (61, 0.00023178483, 1.007373),\n",
       "  (61, 0.00023205229, 1.00863),\n",
       "  (61, 0.00023217167, 1.0095149),\n",
       "  (61, 0.00023221323, 1.0101333),\n",
       "  (61, 0.00023221865, 1.0105625),\n",
       "  (61, 0.0002322098, 1.0108585),\n",
       "  (61, 0.00023219723, 1.0110618),\n",
       "  (61, 0.00023218681, 1.0112007),\n",
       "  (61, 0.00023136527, 1.0057293),\n",
       "  (61, 0.00023188669, 1.0074804),\n",
       "  (61, 0.00023213984, 1.0087212),\n",
       "  (61, 0.00023224653, 1.0095922),\n",
       "  (61, 0.00023227715, 1.0101986),\n",
       "  (61, 0.00023227284, 1.0106174),\n",
       "  (61, 0.00023225584, 1.0109048),\n",
       "  (61, 0.00023223623, 1.0111005),\n",
       "  (61, 0.00023221993, 1.0112332),\n",
       "  (61, 0.00023220794, 1.0113223),\n",
       "  (61, 0.0002320215, 1.0076524),\n",
       "  (61, 0.00023225643, 1.0088675),\n",
       "  (61, 0.00023234682, 1.009716),\n",
       "  (61, 0.00023236306, 1.0103029),\n",
       "  (61, 0.00023234624, 1.0107052),\n",
       "  (61, 0.00023231836, 1.0109786),\n",
       "  (61, 0.00023228955, 1.0111625),\n",
       "  (61, 0.00023226498, 1.011285),\n",
       "  (61, 0.00023224624, 1.0113655),\n",
       "  (61, 0.00023223308, 1.0114177),\n",
       "  (61, 0.00023235008, 1.0089619),\n",
       "  (61, 0.00023242953, 1.0097994),\n",
       "  (61, 0.00023243553, 1.0103756),\n",
       "  (61, 0.00023240957, 1.0107682),\n",
       "  (61, 0.00023237336, 1.0110327),\n",
       "  (61, 0.00023233704, 1.011209),\n",
       "  (61, 0.00023230608, 1.0113246),\n",
       "  (61, 0.0002322814, 1.0113994),\n",
       "  (61, 0.0002322633, 1.0114465),\n",
       "  (61, 0.00023225055, 1.0114753),\n",
       "  (61, 0.00023256004, 1.009932),\n",
       "  (61, 0.00023254566, 1.0104864),\n",
       "  (61, 0.00023250212, 1.0108603),\n",
       "  (61, 0.00023245107, 1.0111095),\n",
       "  (61, 0.00023240241, 1.0112728),\n",
       "  (61, 0.00023236079, 1.0113776),\n",
       "  (61, 0.00023232726, 1.0114434),\n",
       "  (61, 0.00023230177, 1.0114831),\n",
       "  (61, 0.00023228256, 1.0115056),\n",
       "  (61, 0.00023226836, 1.0115174),\n",
       "  (61, 0.00023270171, 1.0106821),\n",
       "  (61, 0.00023263437, 1.0110233),\n",
       "  (61, 0.00023256312, 1.011245),\n",
       "  (61, 0.00023249729, 1.0113852),\n",
       "  (61, 0.00023244106, 1.0114712),\n",
       "  (61, 0.00023239484, 1.011521),\n",
       "  (61, 0.00023235875, 1.0115473),\n",
       "  (61, 0.00023233064, 1.011559),\n",
       "  (61, 0.00023230875, 1.0115615),\n",
       "  (61, 0.00023229216, 1.0115588),\n",
       "  (61, 0.00023277337, 1.0111763),\n",
       "  (61, 0.00023268006, 1.0113714),\n",
       "  (61, 0.00023259525, 1.0114897),\n",
       "  (61, 0.00023252319, 1.0115576),\n",
       "  (61, 0.000232464, 1.0115923),\n",
       "  (61, 0.00023241644, 1.0116065),\n",
       "  (61, 0.0002323789, 1.0116078),\n",
       "  (61, 0.00023234915, 1.0116019),\n",
       "  (61, 0.00023232587, 1.011592),\n",
       "  (61, 0.00023230765, 1.0115807),\n",
       "  (61, 0.00023284677, 1.0115813),\n",
       "  (61, 0.00023273611, 1.0116627),\n",
       "  (61, 0.0002326424, 1.0117),\n",
       "  (61, 0.0002325644, 1.0117098),\n",
       "  (61, 0.00023250101, 1.0117031),\n",
       "  (61, 0.0002324502, 1.0116876),\n",
       "  (61, 0.00023240893, 1.0116677),\n",
       "  (61, 0.00023237593, 1.0116465),\n",
       "  (61, 0.00023234962, 1.0116255),\n",
       "  (61, 0.00023232837, 1.011606),\n",
       "  (61, 0.00023283751, 1.0117407),\n",
       "  (61, 0.00023272855, 1.0117655),\n",
       "  (61, 0.0002326374, 1.0117649),\n",
       "  (61, 0.00023256271, 1.0117495),\n",
       "  (61, 0.00023250212, 1.0117265),\n",
       "  (61, 0.00023245264, 1.0117005),\n",
       "  (61, 0.00023241265, 1.0116739),\n",
       "  (61, 0.00023238023, 1.0116485),\n",
       "  (61, 0.00023235404, 1.0116252),\n",
       "  (61, 0.00023233285, 1.0116044),\n",
       "  (61, 0.00023286545, 1.0119023),\n",
       "  (61, 0.0002327516, 1.0118768),\n",
       "  (61, 0.00023265794, 1.011841),\n",
       "  (61, 0.00023258128, 1.0118016),\n",
       "  (61, 0.00023251853, 1.0117621),\n",
       "  (61, 0.00023246749, 1.0117245),\n",
       "  (61, 0.00023242575, 1.0116901),\n",
       "  (61, 0.00023239164, 1.0116594),\n",
       "  (61, 0.00023236382, 1.0116323),\n",
       "  (61, 0.00023234054, 1.011609),\n",
       "  (61, 0.00023291842, 1.0120655),\n",
       "  (61, 0.00023279799, 1.0119953),\n",
       "  (61, 0.0002326988, 1.0119277),\n",
       "  (61, 0.00023261667, 1.0118651),\n",
       "  (61, 0.00023254956, 1.011809),\n",
       "  (61, 0.00023249432, 1.0117593),\n",
       "  (61, 0.00023244857, 1.011716),\n",
       "  (61, 0.0002324112, 1.011679),\n",
       "  (61, 0.00023237994, 1.0116472),\n",
       "  (61, 0.00023235445, 1.0116203),\n",
       "  (61, 0.00023290212, 1.0120671),\n",
       "  (61, 0.00023278617, 1.0119872),\n",
       "  (61, 0.00023269001, 1.0119147),\n",
       "  (61, 0.00023261056, 1.01185),\n",
       "  (61, 0.00023254514, 1.0117934),\n",
       "  (61, 0.00023249077, 1.0117445),\n",
       "  (61, 0.0002324463, 1.0117025),\n",
       "  (61, 0.00023240905, 1.0116668),\n",
       "  (61, 0.0002323782, 1.0116365),\n",
       "  (61, 0.00023235317, 1.011611),\n",
       "  (61, 0.0002329332, 1.0121179),\n",
       "  (61, 0.00023281365, 1.0120223),\n",
       "  (61, 0.00023271434, 1.0119387),\n",
       "  (61, 0.00023263175, 1.0118665),\n",
       "  (61, 0.00023256341, 1.0118048),\n",
       "  (61, 0.0002325066, 1.0117522),\n",
       "  (61, 0.00023245916, 1.0117078),\n",
       "  (61, 0.00023241993, 1.0116704),\n",
       "  (61, 0.00023238739, 1.0116389),\n",
       "  (61, 0.00023236015, 1.0116125),\n",
       "  (61, 0.0002329491, 1.0121447),\n",
       "  (61, 0.00023282645, 1.0120378),\n",
       "  (61, 0.0002327247, 1.0119468),\n",
       "  (61, 0.00023264013, 1.0118698),\n",
       "  (61, 0.00023256993, 1.011805),\n",
       "  (61, 0.00023251132, 1.0117509),\n",
       "  (61, 0.00023246283, 1.0117054),\n",
       "  (61, 0.00023242278, 1.0116674),\n",
       "  (61, 0.00023238908, 1.0116359),\n",
       "  (61, 0.00023236149, 1.0116096),\n",
       "  (61, 0.00023298664, 1.0121957),\n",
       "  (61, 0.00023285806, 1.0120744),\n",
       "  (61, 0.0002327509, 1.0119733),\n",
       "  (61, 0.00023266173, 1.011889),\n",
       "  (61, 0.0002325874, 1.0118189),\n",
       "  (61, 0.00023252558, 1.0117606),\n",
       "  (61, 0.00023247447, 1.0117123),\n",
       "  (61, 0.00023243169, 1.0116725),\n",
       "  (61, 0.00023239653, 1.0116395),\n",
       "  (61, 0.00023236737, 1.0116122),\n",
       "  (61, 0.00023298914, 1.0121574),\n",
       "  (61, 0.0002328591, 1.0120398),\n",
       "  (61, 0.00023275125, 1.0119425),\n",
       "  (61, 0.00023266091, 1.011862),\n",
       "  (61, 0.00023258629, 1.0117958),\n",
       "  (61, 0.00023252435, 1.011741),\n",
       "  (61, 0.00023247284, 1.0116957),\n",
       "  (61, 0.00023243, 1.0116585),\n",
       "  (61, 0.00023239496, 1.0116278),\n",
       "  (61, 0.00023236603, 1.0116023),\n",
       "  (61, 0.00023298647, 1.0121369),\n",
       "  (61, 0.00023285503, 1.0120198),\n",
       "  (61, 0.00023274566, 1.0119238),\n",
       "  (61, 0.00023265497, 1.0118449),\n",
       "  (61, 0.00023258018, 1.0117803),\n",
       "  (61, 0.00023251813, 1.0117272),\n",
       "  (61, 0.00023246685, 1.0116837),\n",
       "  (61, 0.00023242459, 1.011648),\n",
       "  (61, 0.0002323899, 1.0116187),\n",
       "  (61, 0.00023236132, 1.0115945),\n",
       "  (61, 0.00023300655, 1.0121456),\n",
       "  (61, 0.00023286958, 1.0120242),\n",
       "  (61, 0.00023275602, 1.0119251),\n",
       "  (61, 0.00023266248, 1.0118446),\n",
       "  (61, 0.00023258512, 1.011779),\n",
       "  (61, 0.00023252127, 1.0117252),\n",
       "  (61, 0.00023246877, 1.0116813),\n",
       "  (61, 0.00023242563, 1.0116456),\n",
       "  (61, 0.00023239013, 1.0116163),\n",
       "  (61, 0.00023236091, 1.0115923),\n",
       "  (61, 0.00023295212, 1.0120615),\n",
       "  (61, 0.00023282267, 1.0119537),\n",
       "  (61, 0.00023271592, 1.0118663),\n",
       "  (61, 0.00023262762, 1.0117955),\n",
       "  (61, 0.00023255515, 1.0117381),\n",
       "  (61, 0.00023249566, 1.0116912),\n",
       "  (61, 0.000232447, 1.0116531),\n",
       "  (61, 0.00023240707, 1.0116221),\n",
       "  (61, 0.00023237424, 1.0115967),\n",
       "  (61, 0.00023234758, 1.0115759),\n",
       "  (61, 0.0002329576, 1.012065),\n",
       "  (61, 0.00023282715, 1.0119567),\n",
       "  (61, 0.00023271929, 1.0118687),\n",
       "  (61, 0.00023263023, 1.0117974),\n",
       "  (61, 0.00023255736, 1.0117395),\n",
       "  (61, 0.0002324974, 1.0116923),\n",
       "  (61, 0.0002324481, 1.011654),\n",
       "  (61, 0.00023240782, 1.0116227),\n",
       "  (61, 0.000232375, 1.0115972),\n",
       "  (61, 0.00023234781, 1.0115763),\n",
       "  (61, 0.00023296184, 1.0120676),\n",
       "  (61, 0.00023283018, 1.0119586),\n",
       "  (61, 0.00023272162, 1.0118704),\n",
       "  (61, 0.00023263221, 1.0117987),\n",
       "  (61, 0.00023255887, 1.0117406),\n",
       "  (61, 0.0002324984, 1.0116934),\n",
       "  (61, 0.00023244892, 1.0116549),\n",
       "  (61, 0.00023240852, 1.0116234),\n",
       "  (61, 0.00023237523, 1.0115976),\n",
       "  (61, 0.0002323481, 1.0115767),\n",
       "  (61, 0.00023296481, 1.0120695),\n",
       "  (61, 0.0002328325, 1.0119603),\n",
       "  (61, 0.00023272348, 1.0118716),\n",
       "  (61, 0.00023263384, 1.0117998),\n",
       "  (61, 0.0002325598, 1.0117415),\n",
       "  (61, 0.0002324991, 1.0116938),\n",
       "  (61, 0.00023244944, 1.0116552),\n",
       "  (61, 0.00023240864, 1.0116236),\n",
       "  (61, 0.0002323754, 1.0115979),\n",
       "  (61, 0.00023234828, 1.0115769),\n",
       "  (61, 0.00023296691, 1.0120709),\n",
       "  (61, 0.00023283431, 1.0119615),\n",
       "  (61, 0.00023272505, 1.0118726),\n",
       "  (61, 0.00023263466, 1.0118005),\n",
       "  (61, 0.0002325605, 1.011742),\n",
       "  (61, 0.00023249973, 1.0116943),\n",
       "  (61, 0.00023244967, 1.0116556),\n",
       "  (61, 0.0002324087, 1.011624),\n",
       "  (61, 0.00023237552, 1.0115981),\n",
       "  (61, 0.00023234857, 1.011577),\n",
       "  (61, 0.00023296865, 1.0120721),\n",
       "  (61, 0.00023283571, 1.0119622),\n",
       "  (61, 0.00023272587, 1.0118732),\n",
       "  (61, 0.00023263524, 1.0118011),\n",
       "  (61, 0.00023256114, 1.0117425),\n",
       "  (61, 0.00023249991, 1.0116948),\n",
       "  (61, 0.00023244991, 1.0116558),\n",
       "  (61, 0.00023240893, 1.0116242),\n",
       "  (61, 0.00023237569, 1.0115981),\n",
       "  (61, 0.00023234845, 1.0115771),\n",
       "  (61, 0.00023297011, 1.012073),\n",
       "  (61, 0.00023283646, 1.0119629),\n",
       "  (61, 0.00023272645, 1.0118738),\n",
       "  (61, 0.00023263582, 1.0118014),\n",
       "  (61, 0.00023256114, 1.0117427),\n",
       "  (61, 0.00023250008, 1.011695),\n",
       "  (61, 0.00023244991, 1.011656),\n",
       "  (61, 0.00023240916, 1.0116243),\n",
       "  (61, 0.00023237581, 1.0115983),\n",
       "  (61, 0.00023234863, 1.0115772),\n",
       "  (61, 0.00023297087, 1.0120736),\n",
       "  (61, 0.00023283716, 1.0119635),\n",
       "  (61, 0.00023272686, 1.0118742),\n",
       "  (61, 0.00023263594, 1.0118018),\n",
       "  (61, 0.00023256132, 1.011743),\n",
       "  (61, 0.00023249997, 1.011695),\n",
       "  (61, 0.00023245002, 1.0116562),\n",
       "  (61, 0.00023240922, 1.0116243),\n",
       "  (61, 0.00023237587, 1.0115985),\n",
       "  (61, 0.00023234863, 1.0115772),\n",
       "  (61, 0.00023297139, 1.0120742),\n",
       "  (61, 0.00023283757, 1.0119638),\n",
       "  (61, 0.00023272703, 1.0118746),\n",
       "  (61, 0.00023263606, 1.011802),\n",
       "  (61, 0.00023256138, 1.0117431),\n",
       "  (61, 0.00023250014, 1.0116951),\n",
       "  (61, 0.0002324502, 1.0116563),\n",
       "  (61, 0.00023240922, 1.0116245),\n",
       "  (61, 0.00023237587, 1.0115985),\n",
       "  (61, 0.0002323488, 1.0115774),\n",
       "  (61, 0.0002329718, 1.0120744),\n",
       "  (61, 0.00023283757, 1.0119641),\n",
       "  (61, 0.00023272715, 1.0118747),\n",
       "  (61, 0.00023263606, 1.0118021),\n",
       "  (61, 0.00023256138, 1.0117432),\n",
       "  (61, 0.0002325002, 1.0116953),\n",
       "  (61, 0.00023245008, 1.0116563),\n",
       "  (61, 0.00023240916, 1.0116245),\n",
       "  (61, 0.00023237569, 1.0115986),\n",
       "  (61, 0.00023234868, 1.0115774),\n",
       "  (61, 0.00023297186, 1.0120748),\n",
       "  (61, 0.00023283769, 1.0119642),\n",
       "  (61, 0.00023272721, 1.0118748),\n",
       "  (61, 0.00023263617, 1.0118022),\n",
       "  (61, 0.00023256155, 1.0117433),\n",
       "  (61, 0.00023250032, 1.0116954),\n",
       "  (61, 0.0002324502, 1.0116563),\n",
       "  (61, 0.00023240934, 1.0116246),\n",
       "  (61, 0.00023237587, 1.0115985),\n",
       "  (61, 0.00023234868, 1.0115772)],\n",
       " []]"
      ]
     },
     "execution_count": 76,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "model_manager.generate(midi_files[0], length=50)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {
    "metadata": {}
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Shape of combined array: (1, 10, 6)\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "\n",
    "# Simulating your arrays with the given shapes\n",
    "array1 = np.random.rand(1, 10, 1)\n",
    "array2 = np.random.rand(1, 10, 1)\n",
    "array3 = np.random.rand(1, 10, 1)\n",
    "array4 = np.random.rand(1, 10, 1)\n",
    "array5 = np.random.rand(1, 10, 2)\n",
    "\n",
    "# List of arrays\n",
    "arrays = [array1, array2, array3, array4, array5]\n",
    "\n",
    "# Using np.concatenate to combine them along the last dimension (axis=2)\n",
    "combined_array = np.concatenate(arrays, axis=2)\n",
    "\n",
    "# This will result in a new array of shape (1, 10, 6)\n",
    "print(\"Shape of combined array:\", combined_array.shape)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {
    "metadata": {}
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "slice(4, None, None)"
      ]
     },
     "execution_count": 49,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "slice(4, None)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 81,
   "metadata": {
    "metadata": {}
   },
   "outputs": [],
   "source": [
    "model_manager.save(\"_djai-files/model_manager.keras\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 82,
   "metadata": {
    "metadata": {}
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<Functional name=functional_69, built=True>"
      ]
     },
     "execution_count": 82,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "ModelManager.load(\"_djai-files/model_manager.keras\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "musicbook",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
